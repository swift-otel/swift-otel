#if !(OTLPHTTP || OTLPGRPC)
// Empty when above trait(s) are disabled.
#else
// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/profiles/v1development/profiles.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if canImport(FoundationEssentials)
package import FoundationEssentials
#else
package import Foundation
#endif
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the method of aggregating metric values, either DELTA (change since last report)
/// or CUMULATIVE (total since a fixed start time).
package enum Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used. 
  case unspecified // = 0

  ///* DELTA is an AggregationTemporality for a profiler which reports
  ///changes since last report time. Successive metrics contain aggregation of
  ///values from continuous and non-overlapping intervals.
  ///
  ///The values for a DELTA metric are based only on the time interval
  ///associated with one measurement cycle. There is no dependency on
  ///previous measurements like is the case for CUMULATIVE metrics.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///DELTA metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0+1 to
  ///t_0+2 with a value of 2. 
  case delta // = 1

  ///* CUMULATIVE is an AggregationTemporality for a profiler which
  ///reports changes since a fixed start time. This means that current values
  ///of a CUMULATIVE metric depend on all previous measurements since the
  ///start time. Because of this, the sender is required to retain this state
  ///in some form. If this state is lost or invalidated, the CUMULATIVE metric
  ///values MUST be reset and a new fixed start time following the last
  ///reported measurement time sent MUST be used.
  ///
  ///For example, consider a system measuring the number of requests that
  ///it receives and reports the sum of these requests every second as a
  ///CUMULATIVE metric:
  ///
  ///1. The system starts receiving at time=t_0.
  ///2. A request is received, the system measures 1 request.
  ///3. A request is received, the system measures 1 request.
  ///4. A request is received, the system measures 1 request.
  ///5. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+1 with a value of 3.
  ///6. A request is received, the system measures 1 request.
  ///7. A request is received, the system measures 1 request.
  ///8. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_0 to
  ///t_0+2 with a value of 5.
  ///9. The system experiences a fault and loses state.
  ///10. The system recovers and resumes receiving at time=t_1.
  ///11. A request is received, the system measures 1 request.
  ///12. The 1 second collection cycle ends. A metric is exported for the
  ///number of requests received over the interval of time t_1 to
  ///t_1+1 with a value of 1.
  ///
  ///Note: Even though, when reporting changes since last report time, using
  ///CUMULATIVE is valid, it is not recommended. 
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Opentelemetry_Proto_Profiles_V1development_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]

}

/// ProfilesDictionary represents the profiles data shared across the
/// entire message being sent.
///
/// Note that all fields in this message MUST have a zero value encoded as the first element.
/// This allows for _index fields pointing into the dictionary to use a 0 pointer value
/// to indicate 'null' / 'not set'. Unless otherwise defined, a 'zero value' message value
/// is one with all default field values, so as to minimize wire encoded size.
package struct Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mappings from address ranges to the image/binary/library mapped
  /// into that address range referenced by locations via Location.mapping_index.
  package var mappingTable: [Opentelemetry_Proto_Profiles_V1development_Mapping] = []

  /// Locations referenced by samples via Stack.location_indices.
  package var locationTable: [Opentelemetry_Proto_Profiles_V1development_Location] = []

  /// Functions referenced by locations via Line.function_index.
  package var functionTable: [Opentelemetry_Proto_Profiles_V1development_Function] = []

  /// Links referenced by samples via Sample.link_index.
  package var linkTable: [Opentelemetry_Proto_Profiles_V1development_Link] = []

  /// A common table for strings referenced by various messages.
  /// string_table[0] must always be "".
  package var stringTable: [String] = []

  /// A common table for attributes referenced by various messages.
  /// It is a collection of key/value pairs. Note, global attributes
  /// like server name can be set using the resource API. Examples of attributes:
  ///
  ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
  ///     "/http/server_latency": 300
  ///     "abc.com/myattribute": true
  ///     "abc.com/score": 10.239
  ///
  /// The attribute values SHOULD NOT contain empty values.
  /// The attribute values SHOULD NOT contain bytes values.
  /// The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
  /// double values.
  /// The attribute values SHOULD NOT contain kvlist values.
  /// The behavior of software that receives attributes containing such values can be unpredictable.
  /// These restrictions can change in a minor release.
  /// The restrictions take origin from the OpenTelemetry specification:
  /// https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
  package var attributeTable: [Opentelemetry_Proto_Profiles_V1development_KeyValueAndUnit] = []

  /// Stacks referenced by samples via Sample.stack_index.
  package var stackTable: [Opentelemetry_Proto_Profiles_V1development_Stack] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// ProfilesData represents the profiles data that can be stored in persistent storage,
/// OR can be embedded by other protocols that transfer OTLP profiles data but do not
/// implement the OTLP protocol.
///
/// The main difference between this message and collector protocol is that
/// in this message there will not be any "control" or "metadata" specific to
/// OTLP protocol.
///
/// When new fields are added into this message, the OTLP request MUST be updated
/// as well.
package struct Opentelemetry_Proto_Profiles_V1development_ProfilesData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of ResourceProfiles.
  /// For data coming from an SDK profiler, this array will typically contain one
  /// element. Host-level profilers will usually create one ResourceProfile per
  /// container, as well as one additional ResourceProfile grouping all samples
  /// from non-containerized processes.
  /// Other resource groupings are possible as well and clarified via
  /// Resource.attributes and semantic conventions.
  /// Tools that visualize profiles should prefer displaying
  /// resources_profiles[0].scope_profiles[0].profiles[0] by default.
  package var resourceProfiles: [Opentelemetry_Proto_Profiles_V1development_ResourceProfiles] = []

  /// One instance of ProfilesDictionary
  package var dictionary: Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary {
    get {return _dictionary ?? Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary()}
    set {_dictionary = newValue}
  }
  /// Returns true if `dictionary` has been explicitly set.
  package var hasDictionary: Bool {return self._dictionary != nil}
  /// Clears the value of `dictionary`. Subsequent reads from it will return its default value.
  package mutating func clearDictionary() {self._dictionary = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _dictionary: Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary? = nil
}

/// A collection of ScopeProfiles from a Resource.
package struct Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the profiles in this message.
  /// If this field is not set then no resource info is known.
  package var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  package var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  package mutating func clearResource() {self._resource = nil}

  /// A list of ScopeProfiles that originate from a resource.
  package var scopeProfiles: [Opentelemetry_Proto_Profiles_V1development_ScopeProfiles] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the resource data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to the data in the "resource" field. It does not apply
  /// to the data in the "scope_profiles" field which have their own schema_url field.
  package var schemaURL: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Profiles produced by an InstrumentationScope.
package struct Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation scope information for the profiles in this message.
  /// Semantically when InstrumentationScope isn't set, it is equivalent with
  /// an empty instrumentation scope name (unknown).
  package var scope: Opentelemetry_Proto_Common_V1_InstrumentationScope {
    get {return _scope ?? Opentelemetry_Proto_Common_V1_InstrumentationScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  package var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  package mutating func clearScope() {self._scope = nil}

  /// A list of Profiles that originate from an instrumentation scope.
  package var profiles: [Opentelemetry_Proto_Profiles_V1development_Profile] = []

  /// The Schema URL, if known. This is the identifier of the Schema that the profile data
  /// is recorded in. Notably, the last part of the URL path is the version number of the
  /// schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
  /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
  /// This schema_url applies to all profiles in the "profiles" field.
  package var schemaURL: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _scope: Opentelemetry_Proto_Common_V1_InstrumentationScope? = nil
}

/// Represents a complete profile, including sample types, samples, mappings to
/// binaries, stacks, locations, functions, string table, and additional
/// metadata. It modifies and annotates pprof Profile with OpenTelemetry
/// specific fields.
///
/// Note that whilst fields in this message retain the name and field id from pprof in most cases
/// for ease of understanding data migration, it is not intended that pprof:Profile and
/// OpenTelemetry:Profile encoding be wire compatible.
package struct Opentelemetry_Proto_Profiles_V1development_Profile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type and unit of all Sample.values in this profile.
  /// For a cpu or off-cpu profile this might be:
  ///   ["cpu","nanoseconds"] or ["off_cpu","nanoseconds"]
  /// For a heap profile, this might be:
  ///   ["allocated_objects","count"] or ["allocated_space","bytes"],
  package var sampleType: Opentelemetry_Proto_Profiles_V1development_ValueType {
    get {return _sampleType ?? Opentelemetry_Proto_Profiles_V1development_ValueType()}
    set {_sampleType = newValue}
  }
  /// Returns true if `sampleType` has been explicitly set.
  package var hasSampleType: Bool {return self._sampleType != nil}
  /// Clears the value of `sampleType`. Subsequent reads from it will return its default value.
  package mutating func clearSampleType() {self._sampleType = nil}

  /// The set of samples recorded in this profile.
  package var sample: [Opentelemetry_Proto_Profiles_V1development_Sample] = []

  /// Time of collection (UTC) represented as nanoseconds past the epoch.
  package var timeUnixNano: UInt64 = 0

  /// Duration of the profile, if a duration makes sense.
  package var durationNano: UInt64 = 0

  /// The kind of events between sampled occurrences.
  /// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
  package var periodType: Opentelemetry_Proto_Profiles_V1development_ValueType {
    get {return _periodType ?? Opentelemetry_Proto_Profiles_V1development_ValueType()}
    set {_periodType = newValue}
  }
  /// Returns true if `periodType` has been explicitly set.
  package var hasPeriodType: Bool {return self._periodType != nil}
  /// Clears the value of `periodType`. Subsequent reads from it will return its default value.
  package mutating func clearPeriodType() {self._periodType = nil}

  /// The number of events between sampled occurrences.
  package var period: Int64 = 0

  /// Free-form text associated with the profile. The text is displayed as is
  /// to the user by the tools that read profiles (e.g. by pprof). This field
  /// should not be used to store any machine-readable information, it is only
  /// for human-friendly content. The profile must stay functional if this field
  /// is cleaned.
  package var commentStrindices: [Int32] = []

  /// A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
  /// all zeroes is considered invalid. It may be used for deduplication and signal
  /// correlation purposes. It is acceptable to treat two profiles with different values
  /// in this field as not equal, even if they represented the same object at an earlier
  /// time.
  /// This field is optional; an ID may be assigned to an ID-less profile in a later step.
  package var profileID: Data = Data()

  /// dropped_attributes_count is the number of attributes that were discarded. Attributes
  /// can be discarded because their keys are too long or because there are too many
  /// attributes. If this value is 0, then no attributes were dropped.
  package var droppedAttributesCount: UInt32 = 0

  /// Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
  package var originalPayloadFormat: String = String()

  /// Original payload can be stored in this field. This can be useful for users who want to get the original payload.
  /// Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
  /// Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
  /// If the original payload is in pprof format, it SHOULD not be included in this field.
  /// The field is optional, however if it is present then equivalent converted data should be populated in other fields
  /// of this message as far as is practicable.
  package var originalPayload: Data = Data()

  /// References to attributes in attribute_table. [optional]
  package var attributeIndices: [Int32] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _sampleType: Opentelemetry_Proto_Profiles_V1development_ValueType? = nil
  fileprivate var _periodType: Opentelemetry_Proto_Profiles_V1development_ValueType? = nil
}

/// A pointer from a profile Sample to a trace Span.
/// Connects a profile sample to a trace span, identified by unique trace and span IDs.
package struct Opentelemetry_Proto_Profiles_V1development_Link: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier of a trace that this linked span is part of. The ID is a
  /// 16-byte array.
  package var traceID: Data = Data()

  /// A unique identifier for the linked span. The ID is an 8-byte array.
  package var spanID: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// ValueType describes the type and units of a value, with an optional aggregation temporality.
package struct Opentelemetry_Proto_Profiles_V1development_ValueType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into ProfilesDictionary.string_table.
  package var typeStrindex: Int32 = 0

  /// Index into ProfilesDictionary.string_table.
  package var unitStrindex: Int32 = 0

  package var aggregationTemporality: Opentelemetry_Proto_Profiles_V1development_AggregationTemporality = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Each Sample records values encountered in some program context. The program
/// context is typically a stack trace, perhaps augmented with auxiliary
/// information like the thread-id, some indicator of a higher level request
/// being handled etc.
///
/// A Sample MUST have have at least one values or timestamps_unix_nano entry. If
/// both fields are populated, they MUST contain the same number of elements, and
/// the elements at the same index MUST refer to the same event.
///
/// Examples of different ways of representing a sample with the total value of 10:
///
/// Report of a stacktrace at 10 timestamps (consumers must assume the value is 1 for each point):
///    values: []
///    timestamps_unix_nano: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
///
/// Report of a stacktrace with an aggregated value without timestamps:
///   values: [10]
///    timestamps_unix_nano: []
///
/// Report of a stacktrace at 4 timestamps where each point records a specific value:
///    values: [2, 2, 3, 3]
///    timestamps_unix_nano: [1, 2, 3, 4]
package struct Opentelemetry_Proto_Profiles_V1development_Sample: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to stack in ProfilesDictionary.stack_table.
  package var stackIndex: Int32 = 0

  /// The type and unit of each value is defined by Profile.sample_type.
  package var values: [Int64] = []

  /// References to attributes in ProfilesDictionary.attribute_table. [optional]
  package var attributeIndices: [Int32] = []

  /// Reference to link in ProfilesDictionary.link_table. [optional]
  /// It can be unset / set to 0 if no link exists, as link_table[0] is always a 'null' default value.
  package var linkIndex: Int32 = 0

  /// Timestamps associated with Sample represented in nanoseconds. These
  /// timestamps should fall within the Profile's time range.
  package var timestampsUnixNano: [UInt64] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Describes the mapping of a binary in memory, including its address range,
/// file offset, and metadata like build ID
package struct Opentelemetry_Proto_Profiles_V1development_Mapping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address at which the binary (or DLL) is loaded into memory.
  package var memoryStart: UInt64 = 0

  /// The limit of the address range occupied by this mapping.
  package var memoryLimit: UInt64 = 0

  /// Offset in the binary that corresponds to the first mapped address.
  package var fileOffset: UInt64 = 0

  /// The object this entry is loaded from.  This can be a filename on
  /// disk for the main binary and shared libraries, or virtual
  /// abstractions like "[vdso]".
  package var filenameStrindex: Int32 = 0

  /// References to attributes in ProfilesDictionary.attribute_table. [optional]
  package var attributeIndices: [Int32] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A Stack represents a stack trace as a list of locations.
package struct Opentelemetry_Proto_Profiles_V1development_Stack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// References to locations in ProfilesDictionary.location_table.
  /// The first location is the leaf frame.
  package var locationIndices: [Int32] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Describes function and line table debug information.
package struct Opentelemetry_Proto_Profiles_V1development_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to mapping in ProfilesDictionary.mapping_table.
  /// It can be unset / set to 0 if the mapping is unknown or not applicable for
  /// this profile type, as mapping_table[0] is always a 'null' default mapping.
  package var mappingIndex: Int32 = 0

  /// The instruction address for this location, if available.  It
  /// should be within [Mapping.memory_start...Mapping.memory_limit]
  /// for the corresponding mapping. A non-leaf address may be in the
  /// middle of a call instruction. It is up to display tools to find
  /// the beginning of the instruction if necessary.
  package var address: UInt64 = 0

  /// Multiple line indicates this location has inlined functions,
  /// where the last entry represents the caller into which the
  /// preceding entries were inlined.
  ///
  /// E.g., if memcpy() is inlined into printf:
  ///    line[0].function_name == "memcpy"
  ///    line[1].function_name == "printf"
  package var line: [Opentelemetry_Proto_Profiles_V1development_Line] = []

  /// References to attributes in ProfilesDictionary.attribute_table. [optional]
  package var attributeIndices: [Int32] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details a specific line in a source code, linked to a function.
package struct Opentelemetry_Proto_Profiles_V1development_Line: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to function in ProfilesDictionary.function_table.
  package var functionIndex: Int32 = 0

  /// Line number in source code. 0 means unset.
  package var line: Int64 = 0

  /// Column number in source code. 0 means unset.
  package var column: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Describes a function, including its human-readable name, system name,
/// source file, and starting line number in the source.
package struct Opentelemetry_Proto_Profiles_V1development_Function: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Function name. Empty string if not available.
  package var nameStrindex: Int32 = 0

  /// Function name, as identified by the system. For instance,
  /// it can be a C++ mangled name. Empty string if not available.
  package var systemNameStrindex: Int32 = 0

  /// Source file containing the function. Empty string if not available.
  package var filenameStrindex: Int32 = 0

  /// Line number in source file. 0 means unset.
  package var startLine: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A custom 'dictionary native' style of encoding attributes which is more convenient
/// for profiles than opentelemetry.proto.common.v1.KeyValue
/// Specifically, uses the string table for keys and allows optional unit information.
package struct Opentelemetry_Proto_Profiles_V1development_KeyValueAndUnit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var keyStrindex: Int32 = 0

  package var value: Opentelemetry_Proto_Common_V1_AnyValue {
    get {return _value ?? Opentelemetry_Proto_Common_V1_AnyValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  package var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  package mutating func clearValue() {self._value = nil}

  /// zero indicates implicit (by semconv) or non-defined unit.
  package var unitStrindex: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _value: Opentelemetry_Proto_Common_V1_AnyValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.profiles.v1development"

extension Opentelemetry_Proto_Profiles_V1development_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0AGGREGATION_TEMPORALITY_UNSPECIFIED\0\u{1}AGGREGATION_TEMPORALITY_DELTA\0\u{1}AGGREGATION_TEMPORALITY_CUMULATIVE\0")
}

extension Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ProfilesDictionary"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}mapping_table\0\u{3}location_table\0\u{3}function_table\0\u{3}link_table\0\u{3}string_table\0\u{3}attribute_table\0\u{3}stack_table\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mappingTable) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.locationTable) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.functionTable) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.linkTable) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.stringTable) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.attributeTable) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.stackTable) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mappingTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mappingTable, fieldNumber: 1)
    }
    if !self.locationTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locationTable, fieldNumber: 2)
    }
    if !self.functionTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.functionTable, fieldNumber: 3)
    }
    if !self.linkTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.linkTable, fieldNumber: 4)
    }
    if !self.stringTable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stringTable, fieldNumber: 5)
    }
    if !self.attributeTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributeTable, fieldNumber: 6)
    }
    if !self.stackTable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stackTable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary, rhs: Opentelemetry_Proto_Profiles_V1development_ProfilesDictionary) -> Bool {
    if lhs.mappingTable != rhs.mappingTable {return false}
    if lhs.locationTable != rhs.locationTable {return false}
    if lhs.functionTable != rhs.functionTable {return false}
    if lhs.linkTable != rhs.linkTable {return false}
    if lhs.stringTable != rhs.stringTable {return false}
    if lhs.attributeTable != rhs.attributeTable {return false}
    if lhs.stackTable != rhs.stackTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ProfilesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ProfilesData"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}resource_profiles\0\u{1}dictionary\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceProfiles) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dictionary) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceProfiles, fieldNumber: 1)
    }
    try { if let v = self._dictionary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData, rhs: Opentelemetry_Proto_Profiles_V1development_ProfilesData) -> Bool {
    if lhs.resourceProfiles != rhs.resourceProfiles {return false}
    if lhs._dictionary != rhs._dictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ResourceProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResourceProfiles"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}resource\0\u{3}scope_profiles\0\u{3}schema_url\0\u{c}h\u{f}\u{1}")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.scopeProfiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scopeProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopeProfiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ResourceProfiles) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.scopeProfiles != rhs.scopeProfiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ScopeProfiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScopeProfiles"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}scope\0\u{1}profiles\0\u{3}schema_url\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.profiles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schemaURL) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.profiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profiles, fieldNumber: 2)
    }
    if !self.schemaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles, rhs: Opentelemetry_Proto_Profiles_V1development_ScopeProfiles) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.profiles != rhs.profiles {return false}
    if lhs.schemaURL != rhs.schemaURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Profile"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sample_type\0\u{1}sample\0\u{3}time_unix_nano\0\u{3}duration_nano\0\u{3}period_type\0\u{1}period\0\u{3}comment_strindices\0\u{3}profile_id\0\u{3}dropped_attributes_count\0\u{3}original_payload_format\0\u{3}original_payload\0\u{3}attribute_indices\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sampleType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sample) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.durationNano) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._periodType) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.period) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.commentStrindices) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.profileID) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.originalPayloadFormat) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.originalPayload) }()
      case 12: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sampleType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sample.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sample, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.durationNano != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationNano, fieldNumber: 4)
    }
    try { if let v = self._periodType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.period != 0 {
      try visitor.visitSingularInt64Field(value: self.period, fieldNumber: 6)
    }
    if !self.commentStrindices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.commentStrindices, fieldNumber: 7)
    }
    if !self.profileID.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileID, fieldNumber: 8)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.droppedAttributesCount, fieldNumber: 9)
    }
    if !self.originalPayloadFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.originalPayloadFormat, fieldNumber: 10)
    }
    if !self.originalPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.originalPayload, fieldNumber: 11)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Profile, rhs: Opentelemetry_Proto_Profiles_V1development_Profile) -> Bool {
    if lhs._sampleType != rhs._sampleType {return false}
    if lhs.sample != rhs.sample {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.durationNano != rhs.durationNano {return false}
    if lhs._periodType != rhs._periodType {return false}
    if lhs.period != rhs.period {return false}
    if lhs.commentStrindices != rhs.commentStrindices {return false}
    if lhs.profileID != rhs.profileID {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.originalPayloadFormat != rhs.originalPayloadFormat {return false}
    if lhs.originalPayload != rhs.originalPayload {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Link"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}trace_id\0\u{3}span_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Link, rhs: Opentelemetry_Proto_Profiles_V1development_Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_ValueType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ValueType"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}type_strindex\0\u{3}unit_strindex\0\u{3}aggregation_temporality\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.typeStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.aggregationTemporality) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.typeStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.typeStrindex, fieldNumber: 1)
    }
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 2)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_ValueType, rhs: Opentelemetry_Proto_Profiles_V1development_ValueType) -> Bool {
    if lhs.typeStrindex != rhs.typeStrindex {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Sample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Sample"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stack_index\0\u{1}values\0\u{3}attribute_indices\0\u{3}link_index\0\u{3}timestamps_unix_nano\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stackIndex) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.values) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.linkIndex) }()
      case 5: try { try decoder.decodeRepeatedFixed64Field(value: &self.timestampsUnixNano) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stackIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.stackIndex, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.values, fieldNumber: 2)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 3)
    }
    if self.linkIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.linkIndex, fieldNumber: 4)
    }
    if !self.timestampsUnixNano.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.timestampsUnixNano, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Sample, rhs: Opentelemetry_Proto_Profiles_V1development_Sample) -> Bool {
    if lhs.stackIndex != rhs.stackIndex {return false}
    if lhs.values != rhs.values {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.linkIndex != rhs.linkIndex {return false}
    if lhs.timestampsUnixNano != rhs.timestampsUnixNano {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Mapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Mapping"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}memory_start\0\u{3}memory_limit\0\u{3}file_offset\0\u{3}filename_strindex\0\u{3}attribute_indices\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memoryStart) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryLimit) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.fileOffset) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memoryStart != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryStart, fieldNumber: 1)
    }
    if self.memoryLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryLimit, fieldNumber: 2)
    }
    if self.fileOffset != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileOffset, fieldNumber: 3)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 4)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Mapping, rhs: Opentelemetry_Proto_Profiles_V1development_Mapping) -> Bool {
    if lhs.memoryStart != rhs.memoryStart {return false}
    if lhs.memoryLimit != rhs.memoryLimit {return false}
    if lhs.fileOffset != rhs.fileOffset {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Stack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Stack"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}location_indices\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.locationIndices) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locationIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.locationIndices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Stack, rhs: Opentelemetry_Proto_Profiles_V1development_Stack) -> Bool {
    if lhs.locationIndices != rhs.locationIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Location"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}mapping_index\0\u{1}address\0\u{1}line\0\u{3}attribute_indices\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.mappingIndex) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.line) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.attributeIndices) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mappingIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.mappingIndex, fieldNumber: 1)
    }
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 2)
    }
    if !self.line.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.line, fieldNumber: 3)
    }
    if !self.attributeIndices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.attributeIndices, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Location, rhs: Opentelemetry_Proto_Profiles_V1development_Location) -> Bool {
    if lhs.mappingIndex != rhs.mappingIndex {return false}
    if lhs.address != rhs.address {return false}
    if lhs.line != rhs.line {return false}
    if lhs.attributeIndices != rhs.attributeIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Line"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}function_index\0\u{1}line\0\u{1}column\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.functionIndex) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.functionIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.functionIndex, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Line, rhs: Opentelemetry_Proto_Profiles_V1development_Line) -> Bool {
    if lhs.functionIndex != rhs.functionIndex {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_Function: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Function"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}name_strindex\0\u{3}system_name_strindex\0\u{3}filename_strindex\0\u{3}start_line\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.nameStrindex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.systemNameStrindex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.filenameStrindex) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startLine) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.nameStrindex, fieldNumber: 1)
    }
    if self.systemNameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.systemNameStrindex, fieldNumber: 2)
    }
    if self.filenameStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.filenameStrindex, fieldNumber: 3)
    }
    if self.startLine != 0 {
      try visitor.visitSingularInt64Field(value: self.startLine, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_Function, rhs: Opentelemetry_Proto_Profiles_V1development_Function) -> Bool {
    if lhs.nameStrindex != rhs.nameStrindex {return false}
    if lhs.systemNameStrindex != rhs.systemNameStrindex {return false}
    if lhs.filenameStrindex != rhs.filenameStrindex {return false}
    if lhs.startLine != rhs.startLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Profiles_V1development_KeyValueAndUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".KeyValueAndUnit"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_strindex\0\u{1}value\0\u{3}unit_strindex\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyStrindex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unitStrindex) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.keyStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.keyStrindex, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.unitStrindex != 0 {
      try visitor.visitSingularInt32Field(value: self.unitStrindex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Opentelemetry_Proto_Profiles_V1development_KeyValueAndUnit, rhs: Opentelemetry_Proto_Profiles_V1development_KeyValueAndUnit) -> Bool {
    if lhs.keyStrindex != rhs.keyStrindex {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unitStrindex != rhs.unitStrindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
#endif
